---
title: "Analysis of IPP spar"
author: "Constantinos Yeles"
date: "`r format(Sys.time(), '%a_%b_%d_%Y')`"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## load libraries
```{r load libraries}
suppressPackageStartupMessages({
  library('tidyverse')
  library('data.table')
})
```
## add todate
```{r todate_of_analysis}
todate <- format(Sys.time(), "%d_%b_%Y")
```
## create the dir for the analysis
```{r}
my_exp <- "COLO205_IPP"
dir.create(str_glue("./{my_exp}_analysis"))
dat_path <- str_glue("{my_exp}_analysis")
```

## import data and make dataframe
```{r create_the_df}
path <- "/home/0/R_virtual_shared_folder/3_IPP_PIWIL1/SPAR_results"
smallRNA_files <- dir(path, full.names = TRUE,
                      pattern = "smRNA_gene_expression.xls",
                      recursive = TRUE)
# load the list of files in one table -----
DT <- rbindlist(sapply(smallRNA_files,fread,
                       simplify=FALSE,
                       #select = c(1,2,4,6),
                       verbose=getOption("datatable.verbose", TRUE)),
                use.names= TRUE,idcol="file")  %>%
  rename(smallRNA = "#Gene")

# sep "smallRNA" column to multiple
# separate("smallRNA",c("chr","start","end","strand","smallRNA","DQ"), sep = ":") %>%
#  as_tibble()

# make matrix for DE analysis  -----
dt <- DT %>% group_by(file) %>% select(-RPM) %>%
  spread(key = "file", value = "ReadCount" )

# clean the colnames
names(dt)[3:length(names(dt))] <- names(dt)[3:length(names(dt))] %>%
  str_remove(".+/3_IPP_PIWIL1/SPAR_results/") %>%
  str_remove(".trimmed_.+") %>% 
  str_remove(pattern = "COLO205_IPP_") %>%
  str_remove(pattern = "noAb_")

# create the targets object ----
targets_file <- tibble(
  sample_name = names(dt)[3:length(names(dt))],
  group = as_factor(str_remove(names(dt)[3:length(names(dt))],"_.$")), 
  batch = as_factor(str_remove(names(dt)[3:length(names(dt))],"^.+_"))
)

targ_path <- dir(path = path, 
                 pattern = "Sra",
                 full.names = T,
                 recursive = TRUE)

targets_file <- fread(targ_path) %>% 
  as_tibble() %>% 
  dplyr::select(Run, BioSample, classification, Instrument) %>% 
  mutate_if(is.character, as_factor) 

target <- match(names(dt)[3:length(names(dt))],targets_file$sample_name, nomatch = 0)
tardt <- match(targets_file$Run, names(dt), nomatch = 0)
#dt1 <- dt
names(dt)[tardt] <- as.character(targets_file$samples[target])

stopifnot(identical(targets_file$sample_name,names(dt)[3:length(names(dt))]))

# write the results  -----
dt %>% write_tsv(str_glue("{dat_path}/raw_reads_{todate}_{my_exp}_SPAR.txt"))
```

## Perform various Filtering Methods: EdgeR, NOIseq
```{r}
# load dataset ----
DT <- fread(list.files(path = dat_path, pattern = "raw", full.names = TRUE ))
suppressPackageStartupMessages({library('edgeR')
  library('NOIseq')})# there is a problem loading it 
# I load it manually 
suppressPackageStartupMessages(library('rafalib'))
stopifnot(identical(as.character(targets_file$sample_name),names(dt)[3:length(names(dt))]))
# exploratory analysis with NOISeq -----
mybiotypes <-  dt$GeneClass
names(mybiotypes) <-  dt$smallRNA

# make the matrix  
mat <- dt %>%
  select(-GeneClass) %>%
  column_to_rownames("smallRNA") %>%
  as.matrix()
# make clearer names
colnames(mat) <-  colnames(mat)  %>% 
  str_replace("Control","Ctrl")

targets_file$Run <- colnames(mat)

# NOISeq dataset
mydata <- readData(data = mat, factors = as.data.frame(targets_file), biotype = mybiotypes)

mybiodetection <- dat(mydata, k = 0, type = "biodetection", factor = NULL)
par(mfrow = c(1, 2))
explo.plot(mybiodetection, samples = c(1,3), toplot = "piRNA",plottype = "comparison")
mycountsbio <- dat(mydata, factor = NULL, type = "countsbio")
par(mfrow = c(1,1 ))

pdf(str_glue("{dat_path}/biodetection_expression_{todate}_{my_exp}.pdf"))
sapply(seq(ncol(mat)) ,function(x){
explo.plot(mycountsbio, toplot = 2, samples = x, plottype = "boxplot")
})
dev.off()

# filtering with NOISEq  -----
noiL <- as.list(1L:3)
names(noiL) <- c("cpm", "Wilcoxon", "Prop")
NOISeq_filt <- lapply(noiL, function(x) NOISeq::filtered.data(mat, 
        factor = targets_file$group,
        norm = FALSE, 
        method = x, cv.cutoff=100, cpm=1))

# create the design matrix  -----
design <- model.matrix(~0+ targets_file$group + targets_file$batch)
colnames(design) <- colnames(design) %>% 
  str_remove("targets_file\\$") %>% 
  str_remove("group")

rownames(design) <- targets_file$group

# create the DGElist ----
dgl <- DGEList(counts = mat,
               samples = targets_file,
               lib.size = colSums(mat),
               norm.factors = rep(1,ncol(mat)))

# filterwith EdgeR ----
keep.exprs <- filterByExpr.DGEList(dgl, design = design)
dgl_filt <- dgl[keep.exprs,,keep.lib.sizes=FALSE]

dim(dgl);dim(dgl_filt)
str_glue( "Starting features: {nrow(dgl)}\nedgeR filter, remaining features: {nrow(dgl_filt)}\nCPM approach, remaining features: {nrow(NOISeq_filt[[1]])}\nWilcoxon filter, remaining features: {nrow(NOISeq_filt[[2]])}\nProportion approach filter, remaining features: {nrow(NOISeq_filt[[3]])}")

# if we want to keep noiseq filter instead of edger but use edger object ----
filte_Nois <- dgl[rownames(dgl$counts) %in% rownames(NOISeq_filt[[i]]),,keep.lib.sizes=FALSE]

dgl_filt <- DGEList(counts = NOISeq_filt[[i]],
               samples = targets_file,
               lib.size = colSums(NOISeq_filt[[i]]),
               norm.factors = rep(1,ncol(NOISeq_filt[[i]])))

# finally give colours to samples ----
suppressPackageStartupMessages(library('wesanderson'))
pal1 <- wes_palette(length(levels(as_factor(targets_file$group))),
                    name = "Darjeeling1", type = "discrete") %>%
  enframe(name = NULL) %>%
  mutate(
    group = as_factor(levels(targets_file$group)))

# add color to the DGEList 
dgl_filt$colours <- inner_join(dgl_filt$samples,pal1,by= "group")$value

# plot RLE and other functions from EDASeq ----
suppressPackageStartupMessages(library('EDASeq'))
par(mar=c(8,4,4,2))
EDASeq::plotRLE(dgl_filt$counts, col=dgl_filt$colours, 
                outline=FALSE,las = 2, ylab="Relative Log Expression", 
                cex.axis=1, cex.lab=1, )
EDASeq::plotPCA(dgl_filt$counts, 
                col = dgl_filt$colours, cex=1, cex.axis=1, cex.lab=1)

dataEDA <- EDASeq::newSeqExpressionSet(counts = dgl_filt$counts, 
  phenoData = as.data.frame(dgl_filt$samples, row.names = rownames(dgl_filt$samples)))
EDASeq::meanVarPlot(dataEDA, log=TRUE, ylim=c(0,16))
EDASeq::biasPlot(dataEDA, "gc", log=TRUE, ylim=c(1,5))
```
## histogram
```{r}
AveLogCpm_Raw_Data <- aveLogCPM(dgl)
AveLogCpm_Filtered_Data <-aveLogCPM(dgl_filt)

par(mfrow=c(1,2))

pdf(str_glue("{dat_path}/histogram_plot_{todate}_{my_exp}.pdf"))
hist(AveLogCpm_Raw_Data)
hist(AveLogCpm_Filtered_Data)
dev.off()
```

## proceed with the normalization
```{r}
# not normalized
cpm_unorm <- cpm(dgl_filt,log=F,prior.count=5)
lcpm_unorm <- cpm(dgl_filt,log=TRUE,prior.count=5)
# EDA norm ----
dataOffset <- betweenLaneNormalization(dataEDA,
                                       which="upper",offset=TRUE)

EDASeq::meanVarPlot(dataOffset, log=TRUE, ylim=c(0,16))
# edgeR  ----
norm_method <- list("none" = "none", 
                  "TMM" = "TMM",
                  "TMMwsp" = "TMMwsp",
                  "RLE" = "RLE" )
edger_norm <- lapply(norm_method, function(x){
  calcNormFactors(dgl_filt, method = x)
})

#x1_TMM <- calcNormFactors(dgl_filt, method = "TMM")
#cpm_TMM <- cpm(x1_TMM,normalized.lib.sizes = TRUE)
#lcpm_TMM <- cpm(x1_TMM,normalized.lib.sizes = TRUE, log=TRUE, prior.count=5)

# voom with quality weights ----
voomQW_norm <- mapply(function(x, i)
  voomWithQualityWeights(x, design = design, plot = TRUE, 
                         normalize.method = i), edger_norm[1:3], 
  c("quantile", rep("none",2)), SIMPLIFY = FALSE 
)
# create list of normalized data ------
norm_list <- list("Not normalized" = cpm(edger_norm[[1]],normalized.lib.sizes = TRUE), 
                  "EDA_upperQ" = dataOffset, 
                  "TMM" = cpm(edger_norm[[2]],normalized.lib.sizes = TRUE),
                  "TMMwsp" = cpm(edger_norm[[3]],normalized.lib.sizes = TRUE), 
                  "RLE"  = cpm(edger_norm[[4]],normalized.lib.sizes = TRUE),
                  "voom_Quantile" = 2^voomQW_norm[[1]]$E,
                  "voom_TMM" = 2^voomQW_norm[[2]]$E,
                  "voom_TMMwsp" = 2^voomQW_norm[[3]]$E)

pdf(str_glue("{dat_path}/RLE_plots_{todate}_{my_exp}.pdf"))

sapply(seq_along(norm_list) ,function(x, n, i){ 
       EDASeq::plotRLE(x[[i]], col=dgl_filt$colours,
                       outline=FALSE, las=3, 
                       ylab="Relative Log Expression", 
                       cex.axis=1, cex.lab=1, main = str_glue("{n[[i]]}"));
  legend("topright",
       legend= levels(as_factor(dgl_filt$samples$group)),
       fill = levels(as_factor(dgl_filt$colours)),
       bty="n",
       cex = 0.5, inset = c(.01,.01) )}, x = norm_list, n = names(norm_list))
dev.off()

#cpm_TMM <- cpm(x1_TMM,normalized.lib.sizes = TRUE, prior.count=5)

```
## make h-clustering
```{r Hierarchical clustering}
norm_l <- list(
               "unorm" = cpm(edger_norm[[1]],normalized.lib.sizes = TRUE, log=TRUE, prior.count=5),
               "TMM" = cpm(edger_norm[[2]],normalized.lib.sizes = TRUE, log=TRUE, prior.count=5),
               "TMMwsp" = cpm(edger_norm[[3]],normalized.lib.sizes = TRUE, log=TRUE, prior.count=5),
               "voomQ_QW" = voomQW_norm[[1]]$E,
               "voomTMM_QW" = voomQW_norm[[2]]$E,
               "voomTMMwsp_QW" = voomQW_norm[[3]]$E)

hc_methods <- c("ward.D2",
                #"single","median", "centroid","mcquitty")
                "complete",
                "average")
                
l_d <- lapply(norm_l,function(x)dist(t(x)))

l_hc <- sapply(hc_methods, function(x) lapply(l_d, function(y) hclust(y,method = x)))

names(l_hc) <- rep(rownames(l_hc),times = ncol(l_hc))

pdf(str_glue("{dat_path}/hierarchic_clust_{todate}_{my_exp}.pdf"))
for (i in seq_along(l_hc)) {
  myplclust(l_hc[[i]],
            lab.col = dgl_filt$colours, #x1$colours,pal1$value
            #labels = dgl_filt$samples$ ,  
       xlab = str_glue("{names(l_hc[i])}"),
       main = str_glue("{enframe(l_hc[[i]])$value[7]} - {enframe(l_hc[[i]])$value[5]} - group"))
  legend("topright",
       legend = levels(as_factor(dgl_filt$samples$group)),
       fill = levels(as_factor(dgl_filt$colours)), #x1$colours  
       bty="n",
       cex = 0.9)
}
dev.off()
```

## make MDS plot
```{r}
par(mfrow=c(2,2))
par(mar=c(6,5,2,1)+ 0.1)

pdf(str_glue("{dat_path}/MDS_plot_{todate}_{my_exp}.pdf"))

plotMDS(norm_l[[4]],labels = ,
                col=dgl_filt$colours,dim.plot = c(1,2))
legend("topright",
       legend= levels(targets_file$group),
       fill = levels(as_factor(dgl_filt$colours)),
       bty="n",
       cex = 1.5, inset = c(.01,.09) )

plotMDS(norm_l[[4]], labels = ,
                col=dgl_filt$colours,dim.plot = c(3,4),main="MDS plot")

plotMDS(norm_l[[4]], labels = ,
                col=dgl_filt$colours,dim.plot = c(1,3),main="MDS plot")

plotMDS(norm_l[[4]], labels = ,
                col=dgl_filt$colours,dim.plot = c(2,3),main="MDS plot")
plotMDS(norm_l[[4]], labels = ,
                col=dgl_filt$colours,dim.plot = c(2,4),main="MDS plot")
dev.off()
```

## make PCA plot
```{r}
suppressPackageStartupMessages(library(DESeq2))
# make the Deseq dataset -----
dds <- DESeqDataSetFromMatrix(countData = round(dgl_filt$counts),
                              colData = targets_file,
                              design = ~ batch + group )
dds$group <- relevel(dds$group, ref = "Control")

#vst -----
vsd <- vst(dds, blind = FALSE)

head(assay(vsd), 3)

sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix( sampleDists )
suppressPackageStartupMessages({
library("pheatmap")
library("RColorBrewer")})
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$Run, vsd$group, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)
#rlog -----
rld <- rlog(dds, blind = FALSE)

dds1 <- estimateSizeFactors(dds)
# check the transformations -----
df <- bind_rows(
  as_tibble(log2(counts(dds1, normalized=TRUE)[, 1:2]+1)) %>%
    mutate(transformation = "log2(x + 1)"),
  as_tibble(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_tibble(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))

colnames(df)[1:2] <- c("x", "y")  
# plot them
ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)  
# PCA -----
pdf(str_glue("{dat_path}/PCA_plot_{todate}_{my_exp}.pdf"))
DESeq2::plotPCA(vsd, intgroup = "group")
dev.off()
# MDS -----
mds <- as.data.frame(colData(vsd))  %>%
  cbind(cmdscale(sampleDistMatrix))
ggplot(mds, aes(x = `1`, y = `2`, color = group)) +
  geom_point(size = 3) + coord_fixed()

```
## DE analysis 
```{r}
# DEseq2 ----
dds <- DESeq(dds)
res <- results(dds)
summary(res)
resultsNames(dds)

DEseq2_res_C_Ab_vs_Control <- results(dds, name= "group_C_Ab_vs_Control", alpha = 0.05) %>% 
  as_tibble(rownames = "GeneID") %>% 
  arrange(padj) %>% 
  write_tsv(str_glue("{dat_path}/DEseq2_C_Ab_vs_Ctl_{todate}_{my_exp}.txt"))

DEseq2_res_N_Ab_vs_Control <- results(dds, name= "group_N_Ab_vs_Control", alpha = 0.05) %>% 
  as_tibble(rownames = "GeneID") %>% 
  arrange(padj) %>% 
  write_tsv(str_glue("{dat_path}/DEseq2_N_Ab_vs_Ctl_{todate}_{my_exp}.txt"))

DEseq2_res_INPUT_vs_Control <- results(dds, name= "group_INPUT_vs_Control", alpha = 0.05) %>% 
  as_tibble(rownames = "GeneID") %>% 
  arrange(padj) %>% 
  write_tsv(str_glue("{dat_path}/DEseq2_INPUT_vs_Ctl_{todate}_{my_exp}.txt"))

hist(DEseq2_res_C_Ab_vs_Control$pvalue[DEseq2_res_C_Ab_vs_Control$baseMean > 1], 
     breaks = 0:20/20,
     col = "grey50", border = "white")

deseq2_p <- DEseq2_res_C_Ab_vs_Control %>% 
  mutate(DEseq2 = if_else(
    padj >= 0.05, 0, if_else(
      log2FoldChange > 0, 1, -1
    )
  )) %>% 
  select(smallRNA = "GeneID", DEseq2 )


# region report for DEseq2 -----
suppressPackageStartupMessages(library(regionReport))
dir.create(str_glue("{dat_path}/DESeq2_report_{todate}"), recursive = TRUE)

report <- DESeq2Report(dds, project = str_glue('DESeq2_{todate}_{my_exp}_HTML_report'),
    intgroup = c('group'), outdir = str_glue("{dat_path}/DESeq2_report_{todate}"),
    output = 'index', theme = theme_bw())
# edgeR  ----
edger_norm %>% names()
plotMD(edger_norm[[4]],column = 3)
plotMD(edger_norm[[4]],column = 4)
x1_TMM <- estimateDisp(edger_norm[[2]], design=design, robust=TRUE)
plotBCV(x1_TMM)
fit <- glmQLFit(x1_TMM, design, robust = TRUE)
head(fit$coefficients)
plotQLDisp(fit)
con_mat <- makeContrasts(
  C_vs_Ctl = C_Ab - Control,
  N_vs_Ctl = N_Ab - Control,
  INPUT_vs_Ctl = INPUT - Control,
  levels = design)

edgeR_res_INPUT_vs_Ctl <- glmQLFTest(fit,contrast = con_mat[,"INPUT_vs_Ctl"])

is.de <- decideTests(edgeR_res_INPUT_vs_Ctl)
summary(is.de)
topTags(edgeR_res_INPUT_vs_Ctl,n=10)$table 
plotMD(edgeR_res_INPUT_vs_Ctl,
       status = is.de,
       values = c(1,-1),
       col = c("red","blue"),
       legend="topright")

topedgeR_res_AD_vs_Control <- topTags(edgeR_res_AD_vs_Control, 
                            n = nrow(edgeR_res_AD_vs_Control), 
                            adjust.method = "BH", 
                            sort.by = "PValue", 
                            p.value = 1)$table %>% 
  as_tibble(rownames = "smallRNA") %>% 
  write_tsv(str_glue("{dat_path}/edgeR_res_AD_vs_Ctl_{todate}_{my_exp}.txt"))

hist(topedgeR_res_AD_vs_Control$PValue, breaks = 0:20/20,
     col = "grey50", border = "white")

edgeR_p <- topedgeR_res_AD_vs_Control %>% 
  mutate(edgeR = if_else(
    FDR >= 0.05, 0, if_else(
      logFC > 0, 1, -1
    )
  )) %>% 
  select(smallRNA , edgeR )
# region report for edgeR -----
suppressPackageStartupMessages(library(regionReport))
dir.create(str_glue("{dat_path}/edgeR_report_{todate}"), recursive = TRUE)

report <- edgeReport(edger_norm[[3]], fit, project = str_glue('DESeq2_{todate}_{my_exp}_HTML_report'),
    intgroup = c('group'), outdir = str_glue("{dat_path}/DESeq2_report_{todate}"),
    output = 'index', theme = theme_linedraw())
# voom  ----
voomQW_norm %>% names
vfit <- lmFit(voomQW_norm[[2]], design=design)
vfit <- contrasts.fit(vfit,con_mat)
efit <- eBayes(vfit,robust = TRUE)

results <- decideTests(efit)
a <- vennCounts(results)
mfrow.old <- par()$mfrow
par(mfrow=c(1,2))
vennDiagram(a)
vennDiagram(results, 
    include=c("up", "down"),
    counts.col=c("red", "blue"),
    circle.col = c("red", "blue", "green3"))
par(mfrow=mfrow.old)

voom_res_C_vs_Ctl  <- topTable(efit,
                             coef = "C_vs_Ctl",
                             confint=TRUE,
                             number = nrow(efit),
                             adjust.method = "fdr",
                             sort.by = "p") %>% 
  as_tibble(rownames = "smallRNA") %>% 
  write_tsv(str_glue("{dat_path}/voomQW_TMM_res_C_vs_Ctl_{todate}_{my_exp}.txt"))

voom_res_N_vs_Ctl  <- topTable(efit,
                             coef = "N_vs_Ctl",
                             confint=TRUE,
                             number = nrow(efit),
                             adjust.method = "fdr",
                             sort.by = "p") %>% 
  as_tibble(rownames = "smallRNA") %>% 
  write_tsv(str_glue("{dat_path}/voomQW_TMM_res_N_vs_Ctl_{todate}_{my_exp}.txt"))

voom_res_INPUT_vs_Ctl  <- topTable(efit,
                             coef = "INPUT_vs_Ctl",
                             confint=TRUE,
                             number = nrow(efit),
                             adjust.method = "fdr",
                             sort.by = "p") %>% 
  as_tibble(rownames = "smallRNA")  %>% 
  write_tsv(str_glue("{dat_path}/voomQW_TMM_res_INPUT_vs_Ctl_{todate}_{my_exp}.txt"))

hist(toplvoom_res_AD_vs_Control$P.Value, 
     breaks = 0:20/20,
     col = "grey50", border = "white")

voomQW_p <- voom_res_C_vs_Ctl %>% 
  mutate(voomQW = if_else(
    adj.P.Val >= 0.05, 0, if_else(
      logFC > 0, 1, -1
    )
  )) %>% 
  select(smallRNA , voomQW )

# venn diagram for voom, DEseq2, edger -----
 results <-  deseq2_p %>% 
  inner_join(voomQW_p) %>% 
  inner_join(edgeR_p) %>% select(-smallRNA)

pdf(str_glue("{dat_path}/venn_diagram_DE_{todate}_{my_exp}.pdf"))
vennDiagram(results, 
    include=c("up", "down"),
    counts.col=c("red", "blue"),
    circle.col = c("red", "blue", "green3"))
dev.off()
# checking for DEs between both abs ------
## voom ---
C_IP <- voom_res_C_vs_Ctl %>% 
  filter(adj.P.Val < 0.05,
         logFC > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","C_")})
N_IP <- voom_res_N_vs_Ctl %>% 
  filter(adj.P.Val < 0.05,
         logFC > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","N_")})
INPUT_IP <- voom_res_INPUT_vs_Ctl %>% 
  filter(adj.P.Val < 0.05,
         logFC > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","INPUT_")})

INPUT_IP %>% inner_join(N_IP) %>% 
  select(smallRNA)
INPUT_IP %>% inner_join(C_IP) %>% 
  select(smallRNA)

voom_IPP <- C_IP %>% 
  inner_join(N_IP) %>%
  filter(!smallRNA %in% INPUT_IP$smallRNA) %>% 
  select(smallRNA, C_logFC, C_adj.P.Val, N_logFC, N_adj.P.Val)

## DEseq2 ---
C_D2 <- DEseq2_res_C_Ab_vs_Control %>% 
  filter(padj < 0.05,
         log2FoldChange > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","C_")})
N_D2 <- DEseq2_res_N_Ab_vs_Control %>% 
  filter(padj < 0.05,
         log2FoldChange > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","N_")})
INPUT_D2 <- DEseq2_res_INPUT_vs_Control %>% 
  filter(padj < 0.05,
         log2FoldChange > 1.5) %>% 
  rename_if(is.numeric,function(x){str_replace(x,"^","INPUT_")})

INPUT_D2 %>% inner_join(C_D2) %>% select(GeneID)
INPUT_D2 %>% inner_join(N_D2) %>% select(GeneID)
DEseq_IPP <- C_D2 %>% 
  inner_join(N_D2) %>%
  filter(!GeneID %in% INPUT_D2$GeneID) %>% 
  select(GeneID, C_log2FoldChange, C_padj, N_log2FoldChange, N_padj)
```
#test Granges plyr
```{r}
BiocManager::install("plyranges")
library(plyranges)
library(tidyverse)
library(data.table)

# toy samples taken/modified from BiocWorkshops/fluent-genomic-data-analysis-with-plyranges-----
    set.seed(42)
    pos <- sample(1:10000, size = 100)
    size <- sample(10:50, size = 100, replace = TRUE)
    strand <- sample(c("+","-"), size = 100, replace = TRUE)
    rep1 <- data.frame(seqnames = "chr1", 
                  start = pos,
                  width = size,
                  strand =strand, 
                  counts = round(rnorm(100, mean = 100,sd = 20)))
    rep1 <- as_granges(rep1) 
    seqlengths(rep1) <- 248956422
    genome(rep1) <- "hg38"
    rep2 <- rep1 %>% anchor_center %>% mutate(width = width / 2, counts = counts + 100 ) %>% shift_downstream(8L)
    rep3 <- rep1 %>% shift_upstream(11L) %>% mutate(counts = counts / 2)
    rep4 <- rep3 %>% anchor_start() %>% mutate(width = width * 1.3, counts = counts + 1000 ) %>% shift_downstream(7L)
    rep4[c(1 , 50:70)] <- rep2[c(1, 50:70)] %>% shift_downstream(10L)
    rep5 <- rep4 %>% anchor_center() %>% mutate(width = width * 1.5)
    rep5[c(10:30)] <- rep2[c(20:40)] %>% anchor_center() %>% mutate(width = width / 2)
    intensities <- bind_ranges(rep1, rep2, rep3, rep4, .id = "replicate") %>%
    arrange(start)
    r1 <- intensities %>% group_by(strand,replicate) %>% reduce_ranges_directed() %>% tibble::as_tibble()
    r2 <- intensities %>% group_by(strand) %>%  reduce_ranges_directed() %>% tibble::as_tibble()
    r3 <- intensities %>% reduce_ranges_directed() %>% tibble::as_tibble()
    r4 <- intensities %>% group_by(strand,replicate) %>% reduce_ranges() %>% tibble::as_tibble()
    r5 <- intensities %>% group_by(strand) %>% reduce_ranges()%>% tibble::as_tibble()
    r6 <- intensities %>%  reduce_ranges()%>% tibble::as_tibble()
    sapply(list(r1,r2,r3,r4,r5,r6), nrow)
    identical(r2$end,r3$end)

    r3 <- intensities %>% reduce_ranges_directed()
    rep1 <- rep1  %>%  select(rep_1_counts = "counts",dplyr::everything()) %>% arrange(start)
    rep2 <- rep2  %>%  select(rep_2_counts = "counts",dplyr::everything()) %>% arrange(start)
    r3 %>% join_overlap_left_directed( rep1 ) %>% 
    mutate(rep_1_counts = replace_na(rep_1_counts,0)) %>%  
      join_overlap_left_directed( rep2 ) %>% 
      mutate(rep_2_counts = replace_na(rep_2_counts,0))

    ans <- r3 %>% 
  join_overlap_left_directed( rep1 ) %>%  
  join_overlap_left_directed( rep2 ) %>% 
  mutate(revmap = selfmatch(.)) %>%
  dplyr::mutate_at(dplyr::vars(dplyr::starts_with('rep')), 
                   function(.) ifelse (is.na(.), 0, .) 
    ) %>% 
  group_by(revmap) %>%
  reduce_ranges_directed(
    rep_1_counts = median(rep_1_counts, na.rm = TRUE),
    rep_2_counts = median(rep_2_counts, na.rm = TRUE)
  )
# multiple chrs ----------------
set.seed(420)
seqnames <- rep(str_c("chr", 1:5),20) %>% sample(100, replace = TRUE)
pos <- sample(1:10000, size = 100)
size <- sample(10:50, size = 100, replace = TRUE)
strand <- sample(c("+","-"), size = 100, replace = TRUE)
rep1 <- data.frame(seqnames, 
                   start = pos,
                   width = size,
                   strand =strand, 
                   counts = round(rnorm(100, mean = 100,sd = 20)))
rep1 <- as_granges(rep1) 
isCircular(rep1) <- rep(FALSE,5)
seqlengths(rep1) <- c("chr1" = 248956422, "chr2" = 242193529,
                      "chr3" = 198295559, "chr4" = 190214555,
                      "chr5" = 181538259)
genome(rep1) <- "hg38"
seqinfo(rep1)

rep2 <- rep1 %>% anchor_center %>% mutate(width = width / 2, counts = counts + 100 ) %>% shift_downstream(8L)
rep3 <- rep1 %>% shift_upstream(11L) %>% mutate(counts = counts / 2)
rep4 <- rep3 %>% anchor_start() %>% mutate(width = width * 1.3, counts = counts + 1000 ) %>% shift_downstream(7L)
rep4[c(1 , 50:70)] <- rep2[c(1, 50:70)] %>% shift_downstream(10L)
rep5 <- rep4 %>% anchor_center() %>% mutate(width = width * 1.5)
rep5[c(10:30)] <- rep2[c(20:40)] %>% anchor_center() %>% mutate(width = width / 2)
intensities <- bind_ranges(rep1, rep2, rep3, rep4, .id = "replicate") %>%
  arrange(start)
r1 <- intensities %>% group_by(strand,seqnames) %>% reduce_ranges_directed() %>% tibble::as_tibble()
r2 <- intensities %>% group_by(seqnames) %>%  reduce_ranges_directed() %>% tibble::as_tibble()
r3 <- intensities %>% reduce_ranges_directed() %>% tibble::as_tibble()
r4 <- intensities %>% group_by(strand,seqnames) %>% reduce_ranges() %>% tibble::as_tibble()
r5 <- intensities %>% group_by(strand) %>% reduce_ranges()%>% tibble::as_tibble()
r6 <- intensities %>%  reduce_ranges()%>% tibble::as_tibble()
    sapply(list(r1,r2,r3,r4,r5,r6), nrow)
    identical(r2$end,r3$end)    
r3 <- intensities %>% reduce_ranges_directed() 
rep1 <- rep1  %>% select(rep_1_counts = counts, dplyr::everything()) %>% arrange(start)
rep2 <- rep2  %>% select(rep_2_counts = counts, dplyr::everything()) %>% arrange(start)

ans <- r3 %>% 
  join_overlap_left_directed( rep1 ) %>%  
  join_overlap_left_directed( rep2 ) %>% 
  mutate(revmap = selfmatch(.)) %>%
  dplyr::mutate_at(dplyr::vars(dplyr::starts_with('rep')), 
                   function(.) ifelse (is.na(.), 0, .)
    ) %>% 
  group_by(revmap) %>%
  reduce_ranges_directed(
    rep_1_counts = median(rep_1_counts, na.rm = TRUE),
    rep_2_counts = median(rep_2_counts, na.rm = TRUE)
  )

# real data ------
path <- "/home/0/R_virtual_shared_folder/3_IPP_PIWIL1/SPAR_results"
smallRNA_files <- dir(path, full.names = TRUE,
                      pattern = "peaks_unannot.with_con.+.xls",
                      recursive = TRUE)
DT <- rbindlist(sapply(smallRNA_files,fread,
                       simplify=FALSE,
                       #select = c(1,2,4,6),
                       verbose=getOption("datatable.verbose", TRUE)),
                use.names= TRUE,idcol="samples_file")  %>%
  rename(peakChr = "#peakChr") %>% as_tibble %>% 
  #filter(peakChr == "chr1") %>% 
  mutate(samples_file = samples_file %>% str_remove(".+/3_IPP_PIWIL1/SPAR_results/") %>%
  str_remove(".trimmed_.+") %>% 
  str_remove(pattern = "COLO205_IPP_") %>%
  str_remove(pattern = "noAb_")
           )

gr1 <- DT %>% select(samples_file:peakStrand) %>% 
  select(-peakID) %>% 
  as_granges(seqnames = peakChr,
                         start = peakChrStart,
                         end = peakChrEnd,
                         strand = peakStrand) %>% arrange(start)
sInfo <- Seqinfo(genome="hg38")
seqlevels(sInfo) <- seqlevels(gr1)
seqinfo(gr1)<- sInfo

t1 <- gr1 %>%  group_by(strand,samples_file) %>% 
  reduce_ranges_directed() %>% arrange(start)%>% as_tibble
t2 <- arrange(gr1, start) %>% group_by(seqnames) %>% 
  reduce_ranges_directed() %>% as_tibble
t3 <- arrange(gr1, start) %>%  
  reduce_ranges_directed() %>% as_tibble
t4 <- arrange(gr1, start) %>% group_by(strand,samples_file) %>% 
  reduce_ranges()%>% as_tibble
t5 <- arrange(gr1, start) %>% group_by(strand) %>% 
  reduce_ranges()%>% as_tibble
t6 <- arrange(gr1, start) %>% 
  reduce_ranges()%>% as_tibble
sapply(list(t1,t2,t3,t4,t5,t6), nrow)
identical(t2$end,t3$end)

test23 <- tibble(
  Start_t2 = t2$start,
  End_t2 = t2$end,
  Start_t3 = t3$start,
  End_t3 =  t3$end
) %>% group_by(Start_t2,End_t2)%>% mutate(equal_ST = identical(as.numeric(Start_t2),as.numeric(Start_t3)),
             equal_end = identical(End_t2,End_t3))
test23 %>% group_by(equal_ST) %>% summarise(n())
test23 %>% filter(equal_ST == FALSE)
# make a list with samples names ---- 
smpls_lst <- gr1 %>% as_tibble() %>% 
  distinct(samples_file) %>% 
  arrange(samples_file) %>% 
  deframe() %>% 
  as.list() %>% 
  set_names(.)
# rename the column for next applications -----
grSamples_l <- map(smpls_lst, ~ gr1  %>% 
      filter(samples_file == .x) %>% 
      select(!!str_c(.x, "_peakExpr") := "peakExpressionValue",everything()))
# join each sample with the reduced Granges of all samples -----
t3 <- arrange(gr1, start) %>%  
  reduce_ranges_directed()

test1 <- t3 %>% 
  join_overlap_left_directed( grSamples_l[[1]]) %>% 
  join_overlap_left_directed( grSamples_l[[2]]) %>% 
  join_overlap_left_directed( grSamples_l[[3]]) %>% 
  mutate(revmap = selfmatch(.)) %>%
  dplyr::mutate_at(dplyr::vars(dplyr::ends_with('peakExpr')), 
                   function(.) ifelse(is.na(.), 0, .)) %>% 
  select(-starts_with("samples_file"))

my_reduced_Granges <- test1 %>% 
  group_by(revmap) %>% 
  reduce_ranges_directed

my_median <- test1 %>% select(C_Ab_1_peakExpr, revmap) %>% 
  as_tibble() %>% group_by(revmap) %>% 
  summarize(C_Ab_1_peakExpr = median(C_Ab_1_peakExpr, na.rm = TRUE))

my_1st_med <- my_reduced_Granges %>% 
  as_tibble() %>% 
  inner_join(my_median) %>% as_granges()

  test2 <- test1 %>% 
 filter(seqnames == "chr3_KI270895v1_alt") %>%
  group_by(revmap) %>% 
  reduce_ranges_directed(
    C_Ab_1_peakExpr = median(C_Ab_1_peakExpr, na.rm = TRUE),
    C_Ab_2_peakExpr = median(C_Ab_2_peakExpr, na.rm = TRUE),
    C_Ab_3_peakExpr = median(C_Ab_3_peakExpr, na.rm = TRUE))
test1 %>% filter(revmap == 29100)
result_med_sliced <- my_1st_med %>% filter(seqnames == "chr3_KI270895v1_alt") %>% as_tibble() %>% select(revmap,C_Ab_1_peakExpr)
result_med_test2 <-  test2 %>% as_tibble() %>% select(revmap,C_Ab_1_peakExpr)
identical(result_med_sliced,result_med_test2)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
